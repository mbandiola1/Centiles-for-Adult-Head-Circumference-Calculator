    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const form = document.getElementById('circumference-form');
            const resultsDiv = document.getElementById('results');
            const errorMessageDiv = document.getElementById('error-message');
            const chartContainer = document.getElementById('chart-container');

            const heightFtInput = document.getElementById('height-ft');
            const heightInInput = document.getElementById('height-in');
            const heightCmInput = document.getElementById('height-cm');

            // --- CONSTANTS (Model 1) ---
            const SD = 1.41; // *** Constant Standard Deviation ***
            const SLOPE = 0.08673;
            const INTERCEPTS = { male: 42.4, female: 41.02 };
            const Z_SCORES = { 3: -1.88, 10: -1.28, 25: -0.67, 50: 0, 75: 0.67, 90: 1.28, 97: 1.88 };

            const CM_PER_FOOT = 30.48;
            const CM_PER_INCH = 2.54;

            let isConverting = false;

            // --- CHART SETUP (No changes needed here) ---
            let svg, xScale, yScale;
            const margin = { top: 20, right: 25, bottom: 40, left: 50 };
            let width, height;

            function makeXGridlines() { return d3.axisBottom(xScale).ticks(12); }
            function makeYGridlines() { return d3.axisLeft(yScale).ticks(13); }

            function setupChart(gender) {
                chartContainer.innerHTML = '';

                const containerWidth = chartContainer.clientWidth;
                width = containerWidth - margin.left - margin.right;
                height = 400 - margin.top - margin.bottom;

                const xMin = 140; const xMax = 200;
                const yMin = 50; const yMax = 63;

                xScale = d3.scaleLinear().domain([xMin, xMax]).range([0, width]);
                yScale = d3.scaleLinear().domain([yMin, yMax]).range([height, 0]);

                svg = d3.select("#chart-container").append("svg")
                    .attr("viewBox", `0 0 ${containerWidth} 400`).append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                svg.append("g").attr("class", "grid").attr("transform", `translate(0, ${height})`)
                    .call(makeXGridlines().tickSize(-height).tickFormat(""));
                svg.append("g").attr("class", "grid")
                    .call(makeYGridlines().tickSize(-width).tickFormat(""));

                const lineGenerator = d3.line().x(d => xScale(d.height)).y(d => yScale(d.hc));

                // Generate Centile Data Points using CONSTANT SD (Model 1)
                const centileData = Object.entries(Z_SCORES).map(([centile, z]) => {
                    const dataPoints = [];
                    for (let h = xMin; h <= xMax; h += 1) {
                        const meanHC = INTERCEPTS[gender] + (SLOPE * h);
                        // Use constant SD here
                        const hc = meanHC + (z * SD);
                        dataPoints.push({ height: h, hc: hc, centile: centile, z: z });
                    }
                    return dataPoints;
                });

                // Draw Centile Lines
                centileData.forEach(data => {
                    const centile = parseInt(data[0].centile);
                    let strokeColor = '#1f2937';
                    let strokeDash = (centile === 3 || centile === 25 || centile === 75 || centile === 97) ? '8, 4' : '0';
                    svg.append("path").datum(data).attr("d", lineGenerator)
                        .style("fill", "none").style("stroke", strokeColor)
                        .style("stroke-width", "2px").style("stroke-dasharray", strokeDash)
                        .attr("data-centile", centile);
                    svg.append("text").attr("x", xScale(xMax) + 4).attr("y", yScale(data[data.length - 1].hc))
                        .attr("dy", "0.3em").attr("font-size", "10px").attr("font-weight", "bold")
                        .attr("fill", "#6b7280").text(centile);
                });

                // Draw Axes
                svg.append("g").attr("class", "x axis").attr("transform", `translate(0, ${height})`)
                    .call(d3.axisBottom(xScale).ticks(12)).call(g => g.select(".domain").remove());
                svg.append("g").attr("class", "y axis")
                    .call(d3.axisLeft(yScale).ticks(13)).call(g => g.select(".domain").remove());

                // Axis Labels
                svg.append("text").attr("class", "text-sm text-gray-500").attr("text-anchor", "middle")
                    .attr("x", width / 2).attr("y", height + 35).text("Height (cm)");
                svg.append("text").attr("class", "text-sm text-gray-500").attr("text-anchor", "middle")
                    .attr("transform", "rotate(-90)").attr("y", -margin.left + 15).attr("x", -height / 2)
                    .text("Head Circumference (cm)");

                svg.append("g").attr("id", "intersection-lines-group").attr("opacity", 0);

                // Subject Marker Group
                const markerSize = 8;
                const markerGroup = svg.append("g").attr("id", "subject-marker-group").attr("opacity", 0);
                const marker = markerGroup.append("g").attr("id", "subject-marker").attr("transform", "translate(0,0)");
                marker.append("line").attr("class", "line").attr("x1", -markerSize).attr("y1", -markerSize).attr("x2", markerSize).attr("y2", markerSize);
                marker.append("line").attr("class", "line").attr("x1", -markerSize).attr("y1", markerSize).attr("x2", markerSize).attr("y2", -markerSize);
                markerGroup.append("rect").attr("id", "subject-label-bg").attr("class", "label-bg").attr("width", 1).attr("height", 1).attr("x", 0).attr("y", 0);
                markerGroup.append("text").attr("id", "subject-label").attr("font-size", "12px").attr("font-weight", "bold").attr("fill", "#1f2937").attr("text-anchor", "middle");
            }

            function updateIntersectionLines(xPos, yPos, plotHeight) {
                const intersectionLinesGroup = d3.select("#intersection-lines-group");
                intersectionLinesGroup.html("");
                intersectionLinesGroup.append("line").attr("class", "intersection-line")
                    .attr("x1", xPos).attr("y1", plotHeight).attr("x2", xPos).attr("y2", yPos)
                    .style("stroke", "#ef4444").style("stroke-width", 2);
                intersectionLinesGroup.append("line").attr("class", "intersection-line")
                    .attr("x1", 0).attr("y1", yPos).attr("x2", xPos).attr("y2", yPos)
                    .style("stroke", "#ef4444").style("stroke-width", 2);
                intersectionLinesGroup.attr("opacity", 1);
            }

            function plotSubject(heightValue, circumference, percentile) {
                const group = d3.select("#subject-marker-group");
                const label = d3.select("#subject-label");
                const labelBg = d3.select("#subject-label-bg");
                const xPos = xScale(heightValue);
                const yPos = yScale(circumference);

                d3.select("#subject-marker").attr("transform", `translate(${xPos}, ${yPos})`);
                updateIntersectionLines(xPos, yPos, height); // Use global 'height' for plot height

                const labelText = `Your HC (${percentile.toFixed(1)}%)`;
                label.attr("x", xPos).attr("y", yPos - 18).text(labelText);

                const textBBox = label.node().getBBox();
                const padding = 6;
                labelBg.attr("x", textBBox.x - padding / 2).attr("y", textBBox.y - padding / 2)
                    .attr("width", textBBox.width + padding).attr("height", textBBox.height + padding)
                    .attr("opacity", 1);
                group.attr("opacity", 1);
            }

            setupChart('male'); // Initial chart

            window.addEventListener('resize', () => {
                const currentGender = document.getElementById('gender').value || 'male';
                setupChart(currentGender);
                if (!resultsDiv.classList.contains('hidden')) {
                     const gender = document.getElementById('gender').value;
                     const heightValue = getValidatedHeightCm();
                     const circumference = parseFloat(document.getElementById('circumference').value);
                     if (heightValue && !isNaN(circumference)) {
                        const { percentile } = calculateCircumference(gender, heightValue, circumference);
                        plotSubject(heightValue, circumference, percentile);
                     }
                }
            });

            // --- HEIGHT CONVERSION ---
            function convertCmToImperial(cm) {
                if (isConverting || isNaN(cm) || cm < 140 || cm > 200) {
                    if (isNaN(cm) || cm < 140 || cm > 200) {
                        isConverting = true; heightFtInput.value = ''; heightInInput.value = ''; isConverting = false;
                    } return;
                }
                isConverting = true;
                const totalInches = cm / CM_PER_INCH;
                heightFtInput.value = Math.floor(totalInches / 12);
                heightInInput.value = (totalInches % 12).toFixed(1);
                isConverting = false;
            }
            function convertImperialToCm() {
                 if (isConverting) return;
                isConverting = true;
                const ft = parseFloat(heightFtInput.value) || 0;
                const inches = parseFloat(heightInInput.value) || 0;
                if (ft === 0 && inches === 0) { heightCmInput.value = ''; isConverting = false; return; }
                const calculatedCm = (ft * CM_PER_FOOT) + (inches * CM_PER_INCH);
                heightCmInput.value = (calculatedCm >= 140 && calculatedCm <= 200) ? calculatedCm.toFixed(1) : '';
                isConverting = false;
            }
            heightCmInput.addEventListener('input', () => convertCmToImperial(parseFloat(heightCmInput.value)));
            heightFtInput.addEventListener('input', convertImperialToCm);
            heightInInput.addEventListener('input', convertImperialToCm);

            function getValidatedHeightCm() {
                const cm = parseFloat(heightCmInput.value);
                return (isNaN(cm) || cm < 140 || cm > 200) ? null : cm;
            }

            // --- UTILITIES ---
            function displayMessage(message, isError = false) {
                 errorMessageDiv.classList.toggle('hidden', !isError);
                if (isError) { errorMessageDiv.innerHTML = message; resultsDiv.classList.add('hidden'); }
                else { errorMessageDiv.classList.add('hidden'); }
            }

            // Main Calculation Function (Model 1 - Constant SD, using jStat)
            function calculateCircumference(gender, height, circumference) {
                let meanHC;
                if (gender === 'male') {
                    meanHC = INTERCEPTS.male + (SLOPE * height);
                } else if (gender === 'female') {
                    meanHC = INTERCEPTS.female + (SLOPE * height);
                } else {
                    throw new Error("Invalid gender.");
                }

                // *** Use Constant SD for Z-Score ***
                const zScore = (circumference - meanHC) / SD;

                // *** Use jStat for accurate percentile calculation ***
                const percentile = jStat.normal.cdf(zScore, 0, 1) * 100;

                // *** FINAL CORRECTED INTERPRETATION LOGIC ***
                let interpretation = "";

                if (zScore > 3.0) { 
                    interpretation = `Z > +3.0 SD. SEVERE MACROCEPHALY.`;
                } else if (zScore < -3.0) { 
                    interpretation = `Z < -3.0 SD. SEVERE MICROCEPHALY.`;
                } else if (zScore > 2.0) { 
                    interpretation = `Z > +2.0 SD. MACROCEPHALY. Requires Clinical Review.`;
                } else if (zScore < -2.0) { 
                    interpretation = `Z < -2.0 SD. MICROCEPHALY. Requires Clinical Review.`;
                } else {
                    // This covers the entire clinically expected range from -2.0 to +2.0 SD
                    interpretation = `Head circumference is within the typical expected range (Normocephaly).`;
                }

                return { zScore, percentile, interpretation, meanHC };
            }

            // --- FORM SUBMISSION ---
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                displayMessage("", false);
                const gender = document.getElementById('gender').value;
                const heightCm = getValidatedHeightCm();
                const circumference = parseFloat(document.getElementById('circumference').value);

                if (!gender || heightCm === null || isNaN(circumference)) {
                    displayMessage(`Please ensure all fields are valid and height is 140-200 cm.`, true);
                    d3.select("#subject-marker-group").attr("opacity", 0);
                    d3.select("#intersection-lines-group").attr("opacity", 0);
                    return;
                }

                try {
                    const { zScore, percentile, interpretation, meanHC } = calculateCircumference(gender, heightCm, circumference);
                    document.getElementById('mean-output').textContent = meanHC.toFixed(2) + ' cm';
                    document.getElementById('z-score-output').textContent = zScore.toFixed(2);
                    document.getElementById('percentile-output').textContent = `${percentile.toFixed(1)}%`;
                    document.getElementById('interpretation-output').textContent = interpretation;

                    const interpBox = document.getElementById('interpretation-box');
                    interpBox.className = 'p-4 rounded-lg border'; // Reset classes
                    
                    // *** FINAL CORRECTED COLOR-CODING LOGIC ***
                    if (zScore > 2.0 || zScore < -2.0) {
                         interpBox.classList.add('bg-red-100', 'border-red-300'); // Macro/Microcephaly
                    } else if (zScore > 1.5 || zScore < -1.5) {
                         interpBox.classList.add('bg-yellow-100', 'border-yellow-300'); // Caution Zone
                    } else {
                         interpBox.classList.add('bg-green-100', 'border-green-300'); // Normocephaly
                    }
                    // *****************************************

                    resultsDiv.classList.remove('hidden');
                    setupChart(gender);
                    plotSubject(heightCm, circumference, percentile);

                } catch (error) { console.error(error); displayMessage(error.message, true); }
            });

            // Gender change redraws chart
            document.getElementById('gender').addEventListener('change', (e) => {
                 if (e.target.value) setupChart(e.target.value);
                 d3.select("#subject-marker-group").attr("opacity", 0);
                 d3.select("#intersection-lines-group").attr("opacity", 0);
            });

            // --- DOCUMENTATION TOGGLE ---
            const toggleButton = document.getElementById('toggle-methodology');
            const methodologyContent = document.getElementById('methodology-content');
            const toggleIcon = document.getElementById('toggle-icon');
            toggleButton.addEventListener('click', () => {
                const isHidden = methodologyContent.classList.toggle('hidden');
                toggleIcon.textContent = isHidden ? '+' : '—';
            });

            // Initial setup for demonstration (optional)
            document.getElementById('gender').value = 'male';
            document.getElementById('height-cm').value = '175.7';
            convertCmToImperial(175.7);
            document.getElementById('circumference').value = '57.6'; // Near 50th centile

        });
    </script>
